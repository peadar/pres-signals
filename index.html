<!DOCTYPE html>
<html lang="en">
    <head>
        <title>The ins and outs of signal handlers</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
        <link rel="stylesheet" href="reveal.js/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js/dist/theme/night.css">
        <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">
        <link rel="stylesheet" href="local.css">
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h2>The ins and outs of signal handlers</h2>
                    <p>
                    <br>
                        <i>
                            <br> Peter Edwards, Arista Networks.
                            <br><a href="mailto:peadar@arista.com">peadar@arista.com</a>
                        <br>
                        </i>
                    </p>
                </section>

                <section>
                   <h2>Concepts</h2>
                   <hr>

                   <section>
                      A simple program with a signal handler:
                      <pre>
                         <code class="c" data-external="src/basic.c.html"> </code>
                      </pre>
                      ... and what happens when we run it:
                      <pre>
                         <code class="txt" data-external="src/basic.out.html"> </code>
                      </pre>
                   </section>

                   <section>
                       In that case, our application was asleep inside a
                       system call when the signal arrived, but we don't
                       have to be to receive the signal..
                       <pre>
                         <code class="c" data-external="src/basic-loop.c.html"> </code>
                      </pre>
                      ... and what happens when we run it:
                      <pre>
                         <code class="txt" data-external="src/basic-loop.out.html"> </code>
                      </pre>
                   </section>

                   <section>
                       <h3> So, when and how do we get from the normal flow of
                           execution into a signal handler?</h3>
                       <ul>
                           <li class="fragment"> <strong>Signal
                                   handlers are only ever entered on exiting
                                   the kernel to re-enter user mode (running
                                   your program.)</strong></li>

                           <li class=fragment><strong>On return to user mode, the
                            kernel always checks to see if there are any
                            pending signals</strong></li>
                       </ul>

                   </section>

                   <section>
                      <h3>When a signal is sent to an arbitrary
                      thread (eg, via kill(1)), then the target thread is in
                      one of a number of states</h3>
                      <hr><div></div>

                      <dl>
                         <dt class="fragment">Running user/application code
                            (our second case above)</dt>
                         <dd class="fragment">Sender sends inter-cpu message to
                         cause hardware interrupt on CPU running target
                         process, causing it to enter the kernel to handle the
                         interrupt, and return to usermode</dd>

                         <dt class="fragment">Running code in the kernel
                         (system call, interrupt handler, etc) </dt>

                         <dd class="fragment">Kernel will notice the signal on
                         return to usermode (or sometimes, before potentially
                         blocking.) </dd>

                         <dt class="fragment">
                            Not currently running on a CPU (our first case above)
                         </dt>
                         <dd class="fragment"> Sender will ensure the process
                         is runnable  - eventually the scheduler (which runs in
                         kernel mode), selects it, and returns to usermode</dd>
                         </dd>
                      </dl>

                   </section>
                </section>

                <section>
                   <div>
                      <h2>Some Experiments</h2>
                      <hr>
                   </div>
                   <section>

                      <div class="left-wide-pane">
                          <pre>
                             <code class="c" data-external="src/basic-sigframe.gdb.out.html">
                             </code>
                          </pre>
                      </div>

                      <div class="right-narrow-pane">
                          <p>Lets look at our stack trace a bit more carefully...</p>
                          <ul>
                              <li class="fragment">Where did __restore_rt come from??</li>
                              <li class="fragment">It's the start of a function, so it didn't call
                                  our signal handler...</li>
                              <li class="fragment">What's that syscall instruction going to do?</li>
                              <li class="fragment"> ... <code>asm/unistd_64.h</code> says: 
                                  <pre><code>#define __NR_rt_sigreturn 15</code></pre>
                              </li>
                              <li class="fragment">Something to do with our signal handler!</li>
                          </ul>
                      </div>
                   </section>
                   <section>
                       <br>

                      <div class="left-wide-pane">
                          <pre>
                             <code class="c" data-external="src/basic.c.html">
                             </code>
                             <code style="max-height:16em;" class="c"
                                     data-external="src/basic.strace.html">
                             </code>
                          </pre>
                      </div>

                      <div class="right-narrow-pane">
                         <br>
                          <p> Let's examine our system call returning EINTR a bit</p>
                          <ul>
                              <li class="fragment"> <code>pause</code>
                                  <i>looked</i> like it returned -1/EINTR in
                                  main, but strace says it returned error
                               ERESTARTNOHAND</li>

                              <li class="fragment">A different system call,
                                  <code>rt_sigreturn (remember rt_sigreturn?)</code> did
                                  return-1/EINTR</li>
                              <li class="fragment">Note that our signa() call
                              did not invoke a signal sytem call - it in fact
                              invoked rt_sigaction</li>
                          </ul>
                      </div>

                   </section>
                </section>
                <section>
                   <h2>Some Linux Kernel Spelunking</h2>

                   <section>
                      <h3>System call entry</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/do_syscall_64.c.html">
                             </code>
                         </pre>
                      </div>

                      <div class="right-narrow-pane">
                         <p>Once the <code>syscall</code> instruction is
                         executed, the CPU transfers control to kernel code.
                         The low-level assembler entrypoint organises to store
                         machine state, and calls do_syscall_64 </p>

                         <p>That function uses the syscall number to look up a
                         table, invokes the handler for the call, then returns
                         via <code>syscall_return_slowpath</code></p>

                      </div>
                   </section>

                   <section>
                      <h3>syscall_return_slowpath</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/syscall_return_slowpath.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">
                         <p>This does little - but brings us into prepare_exit_to_usermode()</p>
                      </div>
                   </section>

                   <section>
                      <h3>prepare_exit_to_usermode</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/prepare_exit_to_usermode.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">
                         <p>... and through to <code>exit_to_usermode_loop</code>...</p>
                      </div>
                   </section>

                   <section>
                      <h3>exit_to_usermode_loop</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/exit_to_usermode_loop.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">
                         <p>... and to do_signal (ah! signals!)</p>
                      </div>
                   </section>

                   <section>
                      <h3>do_signal</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/do_signal.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">

                         <p>We finally have our check to see if we need to
                         actually process a signal. If we have a signal
                         handler, we want to invoke that. If not, we'll return
                         to the call site of our system call</p>

                      </div>
                   </section>

                   <section>
                      <h3>handle_signal</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/handle_signal.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">
                         <p>The magic happens here, in setup_rt_frame... </p>
                      </div>
                   </section>

                   <section>
                      <h3>setup_rt_frame (x86_64 64-bit syscall version)</h3>
                      <div class="left-wide-pane">
                         <pre>
                             <code class="c"style="max-height:20em;"
                                     data-external="src/setup_rt_frame.c.html">
                             </code>
                         </pre>
                      </div>
                      <div class="right-narrow-pane">
                         <p><code>get_sigframe</code> returns a pointer to the top of the
                         <strong>user</strong> stack. </p>
                         <p class-"fragment">The rest of
                         <code>setup_rt_frame</code> saves the state that we
                         would have returned to usermode with on the user
                         stack, and then manipulates those machine registers so
                         execution will continue in the signal handler. See
                         what it does with sa_restorer, sa_handler in
                         particular</p>
                      </div>
                   </section>
                </section>

                <section>
                    <h2>References</h2>
                    <dl>
                       <dt> Linux 64-bit kernel entrypoint</dt>
                       <dd>https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L56</dd>

                </section>


                <section>
                    <h2>Acknowledgements</h2>
                </section>

            </div>
        </div>
        <script src="reveal.js/dist/reveal.js"></script>
        <script src="reveal.js/plugin/highlight/highlight.js"></script>
        <script src="reveal.js/plugin/notes/notes.js"></script>
        <script src="reveal.js/plugin/zoom/zoom.js"></script>
        <script>

Reveal.initialize({
    width: '100%',
    height: '100%',
    margin: 0,
    border: 0,
   plugins: [ RevealHighlight, RevealNotes, RevealZoom ],
    dependencies: [
       { src: 'external/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
    ]});
        </script>

    </body>
</html>
